<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <title>ERP, яка не перетворюється на дорогий гальмівний механізм: обмеження 1С / SAP / Dynamics / Odoo – DevLab Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta
    name="description"
    content="Технічний розбір архітектурних обмежень ERP за мотивами статей на Habr: де саме виникають обмеження 1С і як подібні вузькі місця проявляються в SAP / Dynamics / Odoo. Пункт за пунктом — з практичними наслідками для змін, контролю та супроводу."
  />

  <!-- Favicon -->
  <link rel="icon" type="image/svg+xml" href="https://uk.devlab.blog/img/devlab-logo.svg">
  <link rel="alternate icon" type="image/png" sizes="32x32" href="https://uk.devlab.blog/img/devlab-favicon-32.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://uk.devlab.blog/img/devlab-favicon-180.png">

  <!-- Consent Mode (set BEFORE GTM) -->
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('consent','default',{
      analytics_storage:'denied',
      ad_storage:'denied',
      ad_user_data:'denied',
      ad_personalization:'denied',
      functionality_storage:'granted',
      security_storage:'granted'
    });
  </script>

  <!-- Main blog styles -->
  <link rel="stylesheet" href="https://uk.devlab.blog/style/devlab-style.css">

  <!-- Main blog scripts (year + search + views counter) -->
  <script src="https://uk.devlab.blog/js/script.js" defer></script>

  <!-- Structured data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "https://uk.devlab.blog/posts/"
    },
    "headline": "ERP, яка не перетворюється на дорогий гальмівний механізм: аналіз архітектури 1С / SAP / Dynamics / Odoo",
    "description": "Технічний розбір архітектурних обмежень ERP за мотивами статей на Habr: де саме виникають обмеження 1С і як подібні вузькі місця проявляються в SAP / Dynamics / Odoo. Пункт за пунктом — з практичними наслідками для змін, контролю та супроводу.",
    "author": { "@type": "Organization", "name": "DevLab Blog" },
    "publisher": {
      "@type": "Organization",
      "name": "DevLab",
      "logo": { "@type": "ImageObject", "url": "https://uk.devlab.blog/img/devlab-logo.svg" }
    },
    "datePublished": "2026-01-22",
    "dateModified": "2026-01-22"
  }
  </script>

  <link rel="canonical" href="https://uk.devlab.blog/posts/post16-erp-change-friendly-architecture-compare.html">

  <!-- Google Tag Manager -->
  <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-WTZDV4K6');</script>
  <!-- End Google Tag Manager -->
</head>

<body class="post-page">
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WTZDV4K6"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->

  <div class="page">
    <!-- HEADER -->
    <header>
      <div class="wrapper">
        <nav class="nav">
          <a href="/" class="nav-brand">
            <div class="nav-logo" aria-hidden="true">
              <img src="https://uk.devlab.blog/img/devlab-logo.svg" alt="DevLab Blog logo">
            </div>
            <div class="nav-meta">
              <div class="nav-meta-title">DevLab Blog</div>
              <div class="nav-meta-sub">Open-source ERP &amp; automation notes</div>
            </div>
          </a>

          <div class="nav-group">
            <div class="nav-links">
              <a href="/#posts">Статті</a>
              <a href="/#categories">Категорії</a>
              <a href="/#about">Про блог</a>
              <a href="https://devlab.blog" target="_blank" rel="noopener noreferrer">Головний сайт</a>
            </div>
            <div class="nav-lang">
              <a href="https://en.devlab.blog/">EN</a>
              <a href="https://pl.devlab.blog/">PL</a>
              <a href="https://ru.devlab.blog/">RU</a>
              <a href="https://uk.devlab.blog/" class="active">UA</a>
            </div>
          </div>

          <div class="nav-cta">
            <a href="/#posts" class="btn btn-outline">Усі статті</a>
            <a href="/#about" class="btn btn-primary">Що це?</a>
          </div>

          <button class="nav-toggle" aria-label="Toggle navigation">☰</button>
        </nav>
      </div>
    </header>

    <!-- MAIN -->
    <main>
      <div class="wrapper">
        <div class="main-grid">
          <!-- ARTICLE -->
          <article id="post16-erp-change-friendly-architecture-compare">
            <div class="section-title">
              <span>Стаття</span>
              <small><a class="back" href="/">← Назад до всіх статей</a></small>
            </div>

            <header>
              <div class="post-meta">
                <span>ERP · Архітектура · Супровід</span>
                <span>&middot;</span>
                <span>Приблизно 10–12 хв читання</span>
                <span>&middot;</span>
                <span>Технічний розбір (без маркетингу)</span>
              </div>

              <!-- ===================================================== -->
              <div class="post-content">

                <h1 class="hero-title">ERP, яка не перетворюється на дорогий гальмівний механізм</h1>
                <p class="post-subtitle">
                  Чому ERP-системи ламаються однаково: архітектурні обмеження 1С, SAP, Microsoft Dynamics, Odoo та інших ERP-платформ і їхня поведінка під час змін бізнес-правил.
                </p>

                <div class="callout" role="note">
                  <strong>Джерело тез і підхід</strong>
                  <p>
                    За мотивами технічних статей на Habr:
                    <a href="https://habr.com/ru/companies/lsfusion/articles/544982/" target="_blank" rel="noopener noreferrer">
                      «Чому lsFusion, а не 1С?»
                    </a>
                    та
                    <a href="https://habr.com/ru/companies/lsfusion/articles/468415/" target="_blank" rel="noopener noreferrer">
                      «Чому не 1С?»
                    </a>.
                    Далі — інженерна «дешифровка»: механізми, симптоми, діагностика на демо/пілоті та способи зниження ризиків.
                  </p>
                </div>
            </header>

            <!-- ===================================================== -->
            <nav class="post-toc" id="toc">
              <h2>Зміст</h2>
              <ol>

                <li class="has-children">
                  <a class="post-read" href="#intro">Вступ</a>
                  <ol>
                    <li><a class="post-read" href="#intro-why">Чому архітектурні обмеження ERP проявляються однаково</a></li>
                    <li><a class="post-read" href="#intro-what-change">Що вважати «зміною бізнес-правил»</a></li>
                    <li><a class="post-read" href="#intro-how-to-read">Як читати розбір і що він дає на практиці</a></li>
                  </ol>
                </li>

                <li class="has-children">
                  <a class="post-read" href="#data-model">Модель даних і обчислень</a>
                  <ol>
                    <li><a class="post-read" href="#limit-2-1"> Об’єкти: довідники, документи тощо</a></li>
                    <li><a class="post-read" href="#limit-2-2"> Неоптимальне отримання даних об’єктів</a></li>
                    <li><a class="post-read" href="#limit-2-3"> Таблиці й подання: регістри</a></li>
                    <li><a class="post-read" href="#limit-2-4"> Регістри працюють лише у дуже приватних випадках</a></li>
                    <li><a class="post-read" href="#limit-2-5"> Немає обмежень і подій для значень регістрів</a></li>
                    <li><a class="post-read" href="#limit-2-6"> Параметри вибірок — лише константні</a></li>
                  </ol>
                </li>

                <li class="has-children">
                  <a class="post-read" href="#query-layer">Запитний рівень і робота з даними</a>
                  <ol>
                    <li><a class="post-read" href="#limit-3-1"> Запити як самостійний шар системи</a></li>
                    <li><a class="post-read" href="#limit-3-2"> Запити у вигляді рядків</a></li>
                    <li><a class="post-read" href="#limit-3-3"> Передбачувана оптимізація (симптоми слабкого оптимізатора)</a></li>
                    <li><a class="post-read" href="#limit-3-4"> Відсутність розширених SQL-можливостей</a></li>
                    <li><a class="post-read" href="#limit-3-5"> Немає запитів для масових змін</a></li>
                  </ol>
                </li>

                <li class="has-children">
                  <a class="post-read" href="#execution-flow">Потік виконання і гарантії консистентності</a>
                  <ol>
                    <li><a class="post-read" href="#limit-4-1"> Відмова від автоматичних блокувань</a></li>
                    <li><a class="post-read" href="#limit-4-2"> Відмова від єдиного потоку виконання</a></li>
                    <li><a class="post-read" href="#limit-4-3"> Відмова від синхронності та чіткого commit point</a></li>
                  </ol>
                </li>

                <li class="has-children">
                  <a class="post-read" href="#forms-layer">Форми та подання даних</a>
                  <ol>
                    <li><a class="post-read" href="#limit-5-1"> Форми як окремий шар логіки</a></li>
                    <li><a class="post-read" href="#limit-5-2"> Відмова від WYSIWYG: читання vs запис</a></li>
                    <li><a class="post-read" href="#limit-5-3"> Обмеження контексту списків і форм</a></li>
                    <li><a class="post-read" href="#limit-5-4"> Надлишкові рівні абстракції в UI</a></li>
                  </ol>
                </li>

                <li class="has-children">
                  <a class="post-read" href="#language-architecture">Архітектура мови та розширюваність</a>
                  <ol>
                    <li><a class="post-read" href="#limit-6-1"> Немає спадкування й поліморфізму</a></li>
                    <li><a class="post-read" href="#limit-6-2"> Немає явної типізації</a></li>
                    <li><a class="post-read" href="#limit-6-3"> Немає справжньої модульності</a></li>
                    <li><a class="post-read" href="#limit-6-4"> Ставка на візуальне програмування</a></li>
                  </ol>
                </li>

                <li class="has-children">
                  <a class="post-read" href="#physical-model">Фізична модель і відкритість системи</a>
                  <ol>
                    <li><a class="post-read" href="#limit-7-1"> Закрита фізична модель даних</a></li>
                    <li><a class="post-read" href="#limit-7-2"> Статична фізична модель даних</a></li>
                    <li><a class="post-read" href="#limit-7-3"> Закриті вихідні коди та ліцензії</a></li>
                  </ol>
                </li>

                <li class="has-children">
                  <a class="post-read" href="#operational-constraints">Експлуатаційні та культурні обмеження</a>
                  <ol>
                    <li><a class="post-read" href="#limit-8-1"> Ліцензування та брендованість</a></li>
                    <li><a class="post-read" href="#limit-8-2"> Фатальний недолік як сума рішень</a></li>
                  </ol>
                </li>

                <li class="has-children">
                  <a class="post-read" href="#demo-pilot-check">Як перевіряти на демо та пілоті</a>
                  <ol>
                    <li><a class="post-read" href="#demo-what-to-ask"> Три зміни для перевірки</a></li>
                    <li><a class="post-read" href="#demo-what-to-watch"> На що дивитися під час демонстрації</a></li>
                    <li><a class="post-read" href="#demo-red-flags"> Типові червоні прапорці</a></li>
                    <li><a class="post-read" href="#demo-result"> Що вважати добрим результатом пілота</a></li>
                  </ol>
                </li>

                <li class="has-children">
                  <a class="post-read" href="#conclusion">Висновки</a>
                  <ol>
                    <li><a class="post-read" href="#conclusion-title"> Висновок (розділ)</a></li>
                    <li><a class="post-read" href="#sources">Джерела та посилання</a></li>
                    <li><a class="post-read" href="#related-posts">Схожі статті</a></li>
                    <li><a class="post-read" href="#feedback">Швидкий фідбек</a></li>
                  </ol>
                </li>

              </ol>
            </nav>

            <!-- ===================================================== -->
            <section class="post-content" id="intro">

              <h2 id="intro-why">1.1 Чому архітектурні обмеження ERP проявляються однаково</h2>
              <p>
                Більшість ERP (1С, SAP, Microsoft Dynamics, Odoo) на старті виглядають стійко: даних мало, процеси спрощені,
                винятки рідкі, інтеграції «тонкі». Архітектурні обмеження в цей момент майже не помітні.
              </p>
              <p>
                Проблеми проявляються пізніше — коли компанія починає змінювати правила. Причина не в «поганій системі»,
                а в тому, що типові ERP побудовані навколо схожих компромісів: об’єктна модель, окремий шар звітності,
                рознесена логіка (форма/сервер/інтеграції), а також обмеження запитного шару та масових операцій.
                За зростання даних і кількості винятків ці компроміси дають однакові симптоми незалежно від вендора.
              </p>

              <div class="callout" role="note">
                <strong>Важливо</strong>
                <p>
                  Цей матеріал не відповідає на запитання «яка ERP краща». Він відповідає на інше:
                  <strong>де і чому дорожчає зміна правил</strong>, і як це розпізнати до промислового запуску.
                </p>
              </div>

              <hr>

              <h2 id="intro-what-change">1.2 Що вважати «зміною правил», а не доопрацюванням</h2>
              <p>
                «Зміна правил» — це не «додати поле» і не «зробити новий звіт». Це зміна, яка одночасно:
              </p>
              <ul>
                <li><strong>змінює поведінку транзакцій</strong> (валідність, проведення, статуси, обмеження);</li>
                <li><strong>змінює показники</strong> (маржа, собівартість, ліміти, залишки, ризик);</li>
                <li><strong>змінює контроль</strong> (блокування, погодження, заборони за умовами);</li>
                <li><strong>не має ламати</strong> звітність та інтеграції (CRM/WMS/маркетплейси/BI).</li>
              </ul>
              <p>
                Якщо платформа не тримає це як єдину модель (дані + розрахунки + контроль), правило неминуче реалізується
                у кількох місцях. Тоді вартість зміни визначається не складністю формули, а кількістю шарів,
                які потрібно синхронно змінювати й перевіряти.
              </p>

              <hr>

              <h2 id="intro-how-to-read">1.3 Як читати цей розбір і що він дає на практиці</h2>
              <p>
                Далі йдуть конкретні архітектурні пункти (об’єкти, регістри, запити, форми, блокування, типізація тощо).
                Для кожного пункту використовується один і той самий формат:
              </p>
              <ul>
                <li><strong>Що мається на увазі</strong> — обмеження без загальних слів;</li>
                <li><strong>Як це проявляється</strong> у 1С / SAP / Dynamics / Odoo (типові механізми, а не «в цілому складно»);</li>
                <li><strong>Який симптом ви побачите</strong> в експлуатації (що реально «болить»);</li>
                <li><strong>Як перевірити на демо/пілоті</strong> — запитання або сценарій, який «розкриває» проблему.</li>
              </ul>

              <div class="callout" role="note">
                <strong>Практичний результат</strong>
                <p>
                  Після цього розбору ви зможете швидко відрізняти:
                  «правка правила» (передбачувана робота в одному місці)
                  від «правки системи» (мультишарові зміни з дорогим регресом),
                  і заздалегідь розуміти, де виникає залежність від вендора або окремих спеціалістів.
                </p>
              </div>

            </section>

            <div class="callout" role="note">
              <strong>Чек-лист: як швидко зрозуміти, чи стане ERP «дорогим гальмом»</strong>
              <ul>
                <li>
                  <strong>Одне правило — одне місце?</strong><br>
                  Попросіть показати, де «живе» конкретне правило (наприклад, ліміт/маржа/залишок) і скільки шарів воно зачіпає.
                  Якщо це код + форма + звіт + обробка — зміни будуть дорогими.
                </li>
                <li>
                  <strong>Чи є «момент завершення» операції?</strong><br>
                  Запитайте, коли операція вважається остаточно виконаною (commit point) і що відбувається асинхронно після «успіху».
                  Якщо відповідь розпливчаста — чекайте «відкладених помилок» і ручних перевірок.
                </li>
                <li>
                  <strong>Перевірка на винятки</strong><br>
                  Додайте 2–3 винятки до типової логіки. Якщо відразу з’являються «приватні обробки» — модель не тримає варіативність.
                </li>
                <li>
                  <strong>Регрес контрольований?</strong><br>
                  Запитайте, як перевіряють, що зміна правила не зламала звіти/інтеграції. Якщо «подивимося очима» — буде боляче.
                </li>
                <li>
                  <strong>Чи можна прогнозувати вартість наступної зміни?</strong><br>
                  Добра архітектура дозволяє наперед сказати: “зміна зачепить N механізмів і перевіряється такими-то тестами”.
                  Погана — перетворює кожну правку на дослідження.
                </li>
              </ul>
            </div>

            <hr>

            <!-- ===================================================== -->
            <section class="post-content" id="data-model">

              <h2 id="data-model-title">2. Модель даних і обчислень</h2>
              <p>
                Цей розділ — про фундамент: <strong>як в ERP влаштовані дані й обчислення</strong>
                та які обмеження закладаються ще до коду, форм та інтеграцій.
                Саме тут визначається, чи можна виразити бізнес-правила як єдину модель
                або вони неминуче «розповзатимуться» по системі.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-2-1">2.1 Об’єкти: довідники, документи тощо</h3>

              <p><strong>Як це зазвичай реалізовано в ERP</strong></p>
              <p>
                Більшість ERP будуються навколо об’єктної моделі:
                довідники, документи, рядки, рухи.
                Бізнес-логіка прив’язується до життєвого циклу об’єкта
                (створення, редагування, проведення),
                а не описується як окрема система правил.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Метадані (Довідники, Документи, Регістри) — основа архітектури.
                Перевірки та розрахунки розподіляються між проведенням,
                модулями форм і службовими обробниками.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Об’єктна модель доповнюється налаштуваннями та розширеннями,
                але правило часто виявляється композицією стандартного об’єкта,
                кастомного коду і процесного шару.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Entities слугують точкою входу,
                але логіка розподіляється між плагінами,
                автоматизаціями та клієнтськими правилами.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                ORM-моделі виглядають цілісно,
                але зі зростанням кастомізації логіка розподіляється
                між моделями, computed fields та модулями.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                одне бізнес-правило реалізовано в кількох об’єктах і шарах;
                пояснення «чому система так порахувала» потребує знання історії впровадження.
              </p>

              <p>
                <strong>Як перевірити:</strong>
                попросити показати одне правило
                й усі об’єкти, де воно реалізоване або впливає на поведінку.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-2-2">2.2 Неоптимальне отримання даних об’єктів</h3>

              <p><strong>Як це зазвичай реалізовано в ERP</strong></p>
              <p>
                Об’єкти зручні для транзакцій,
                але погано підходять для складних обчислень.
                У підсумку дані витягуються частково запитами,
                частково через об’єкти,
                а розрахунок збирається процедурно.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Типовий сценарій: запит + читання об’єктів + цикли.
                Продуктивність залежить від дисципліни розробника.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Дані доступні через кілька рівнів моделі,
                що ускладнює контроль фактичних вибірок.
              </p>

              <p><strong>Dynamics</strong></p>
              <p>
                ORM/API легко породжують багато звернень
                замість однієї оптимальної вибірки.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                ORM приховує реальні запити;
                проблеми проявляються зі зростанням даних.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                система деградує за продуктивністю
                не одразу, а «раптом» — зі збільшенням обсягу.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-2-3">2.3 Таблиці й подання: регістри</h3>

              <p><strong>Як це зазвичай реалізовано в ERP</strong></p>
              <p>
                Для аналітики вводиться окремий шар:
                агрегати, рухи, подання.
                Виникає друге джерело істини,
                відмінне від транзакційних даних.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Регістри — ключовий механізм,
                але логіка розрахунку часто частково залишається в коді.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Аналог — поєднання рухів,
                агрегатів і аналітичних подань.
              </p>

              <p><strong>Dynamics</strong></p>
              <p>
                Агрегати часто виносять у BI або вітрини.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Типові агрегати є,
                але зі зростанням вимог з’являються SQL views і зовнішня аналітика.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                операції та звіти розходяться,
                перерахунки потребують спеціальних процедур.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-2-4">2.4 Регістри працюють лише у дуже приватних випадках</h3>

              <p><strong>Що мається на увазі</strong></p>
              <p>
                Аналітичний шар (регістри/агрегати/вітрини) добре працює, поки бізнес-правило вкладається
                в «типовий» патерн: залишки, обороти, прості розрізи, стандартні періоди.
                Щойно з’являється нетипова семантика (винятки, умовні правила, альтернативні джерела,
                історичне «як було на дату» за нестандартною ознакою), частина логіки перестає виражатися
                в моделі й іде в код/обробки/інтеграції.
              </p>

              <p><strong>Як це проявляється в стандартних ERP</strong></p>

              <p><strong>1С</strong></p>
              <p>
                Регістри (накопичення/бухгалтерії/відомостей) покривають багато сценаріїв,
                але реальна логіка часто «розпадається»: частина — у рухах під час проведення,
                частина — в запитах звітів (СКД), частина — в обробках перерахунку.
                Щойно потрібен «нештатний» алгоритм (умовні перерахунки, складні винятки, альтернативна оцінка),
                він іде в процедурний код і перестає бути частиною єдиної моделі.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Типові обліки й аналітика тримаються на багатій моделі та механізмах розширення,
                але «нестандарт» часто реалізується сумішшю налаштувань + розширень + окремої аналітичної моделі
                (або винесенням в окремий шар аналітики). У підсумку правило існує одразу в кількох місцях,
                а синхронізація стає проєктом.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                У типовому контурі показники часто «розводяться» по шарах: транзакційні сутності,
                правила/плагіни, звітні подання та зовнішня аналітика. Нестандартні правила
                майже неминуче опиняються в комбінації: код + low-code автоматизації + вітрина/BI.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Базові агрегати й computed-поля працюють до певної складності.
                Далі з’являються: окремі моделі для «похідних» показників, SQL views,
                фонові перерахунки та зовнішня аналітика. Правило перестає бути «частиною моделі»
                і перетворюється на набір реалізацій.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                частина правил живе в «моделі» (регістри/агрегати), частина — в «особливих обробках».
                Невелика зміна починає вимагати правок у кількох місцях, а пояснюваність
                «чому так порахувалося» падає.
              </p>

              <p>
                <strong>Як перевірити на демо/пілоті:</strong>
                попросити взяти один показник (наприклад, доступний залишок/маржа/ліміт) і додати
                2–3 винятки (на кшталт типу клієнта, складу, дати, альтернативного джерела ціни).
                Подивіться, чи зберігається <em>єдиний механізм</em> (одне місце/один тип механізму) або правило «розповзається»
                на код + звіт + перерахунок + інтеграцію.
              </p>

              <h3 id="limit-2-5">2.5 Немає обмежень і подій для значень регістрів</h3>
              <hr>

              <p><strong>Що мається на увазі</strong></p>
              <p>
                У багатьох ERP обмеження та події добре визначені для операцій (документ/проведення/запис),
                але погано визначені для <strong>обчислених/агрегованих значень</strong> (залишки, ліміти, рейтинги, ризик).
                Тобто платформа не дає нативного механізму рівня:
                «якщо агрегат став таким — заборони/сповісти/запусти реакцію», як частину моделі.
                Тому контроль реалізують процедурно: перевірками під час проведення, фоновими перевірками,
                звітами-валідаторами та ручними регламентами.
              </p>

              <p><strong>Як це проявляється в стандартних ERP</strong></p>

              <p><strong>1С</strong></p>
              <p>
                Типовий шлях — перевіряти «на місці» під час проведення документа або у формі.
                Але агрегат (наприклад, ліміт/залишок/обіговість) може змінюватися не лише з одного документа:
                з кількох видів операцій, ретро-змін, перерахунків, обмінів. Тоді контроль починає дублюватися,
                а «коли саме спрацює заборона» залежить від сценарію.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Контроль часто будують через статуси/процеси/перевірки в транзакціях,
                а моніторинг агрегатів — окремими механізмами (процедури контролю, звіти, workflow).
                Формально це потужно, але правило частіше стає процесною конструкцією,
                а не декларативним обмеженням на значення.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Бізнес-правила й плагіни зручно чіпляти на подію зміни сутності,
                але агрегати зазвичай рахуються окремо (фон, інтеграція, звітний шар).
                У результаті «обмеження на агрегат» реалізується як набір перевірок + автоматизацій,
                і його важко доказово зробити повним (без дір).
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Є constraints і onchange на рівні моделей, але агрегати часто живуть у computed fields,
                які можуть перераховуватися ліниво/за тригерами/за cron. Тому контроль за агрегатом
                легко стає недетермінованим: «інколи ловить, інколи ні», якщо не вибудувати жорстку дисципліну.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                заборони та контроль працюють «не завжди однаково»:
                один користувач ловить обмеження одразу, інший — пізніше;
                частина порушень виявляється звітом/перевіркою постфактум.
                З’являються регламенти «перевіряйте вручну».
              </p>

              <p>
                <strong>Як перевірити на демо/пілоті:</strong>
                попросити зробити обмеження на агрегат:
                «не можна відвантажувати, якщо сумарний ризик/ліміт по клієнту &gt; X, з урахуванням усіх документів і коригувань».
                Далі попросити показати 3 способи зміни агрегата (документ, коригування заднім числом, інтеграція/імпорт)
                і переконатися, що обмеження спрацьовує однаково в усіх трьох сценаріях.
              </p>

              <hr>

              <h3 id="limit-2-6">2.6 У параметрах віртуальних таблиць можна використовувати лише константи</h3>

              <p><strong>Що мається на увазі</strong></p>
              <p>
                Коли аналітичний шар можна параметризувати лише константами (або дуже обмежено),
                система не вміє «підлаштовувати» обчислення під контекст операції.
                У результаті доводиться:
                (1) вибирати дані «ширше, ніж потрібно», а потім фільтрувати в коді/формі,
                (2) створювати копії запитів/звітів під різні варіанти,
                (3) виносити частину логіки з моделі в процедурні шари.
                Це тихо збільшує вартість змін: кожна нова умова породжує нові копії.
              </p>

              <p><strong>Як це проявляється в стандартних ERP</strong></p>

              <p><strong>1С</strong></p>
              <p>
                Типовий ефект: звіт/запит «універсальний» лише на словах.
                Щойно з’являються умови «залежні від контексту» (поточний користувач, роль, стан документа,
                параметри форми), частина фільтрації йде в код, а запити копіюються.
                З часом виникає «зоопарк» варіантів майже однакових звітів/вибірок.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Контекстні умови часто вирішуються налаштуваннями, параметрами подань і процесними шарами,
                але зі зростанням варіативності з’являється той самий патерн: різні варіанти подань/запитів/ролей
                замість одного описаного правила. Ціна — складність супроводу та ризик розходження логіки.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Обмеження виразів і контексту призводять до розмноження подань/запитів/flows:
                «для цієї ролі одне», «для цієї форми інше». Коли бізнес змінює правило,
                доводиться шукати всі копії та синхронно правити.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                ORM зручний, але складний контекст часто приводить до:
                доменів/контекстів на рівні UI + окремих методів вибірки в коді + SQL для важких випадків.
                Варіативність фільтрів швидко породжує дублікати та «локальні рішення».
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                з’являються «майже однакові» звіти, списки та вибірки.
                Невелика зміна умови (ще один фільтр/виняток) перетворюється на серію правок:
                запит, код форми, права, окремий звіт, окрема обробка.
              </p>

              <p>
                <strong>Як перевірити на демо/пілоті:</strong>
                попросити реалізувати один і той самий список/звіт із 3 контекстами:
                (1) для бухгалтера, (2) для менеджера, (3) для керівника — з різними фільтрами та колонками,
                але з одним джерелом правила. Потім попросити змінити правило (додати виняток)
                і подивитися, змінюють це в одному місці чи в кількох копіях.
              </p>

            </section>

            <!-- ===================================================== -->
            <section class="post-content" id="query-layer">

              <h2 id="query-layer-title">3. Запитний рівень і робота з даними</h2>
              <p>
                Цей розділ — про те, <strong>наскільки запити є керованою частиною архітектури ERP</strong>.
                Тут стає видно, чи можна виражати бізнес-логіку декларативно
                і передбачувано керувати її вартістю,
                чи будь-які зміни перетворюються на ризик за продуктивністю та регресом.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-3-1">3.1 Запити як самостійний шар системи</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                У більшості ERP запити призначені для читання даних і звітності.
                Бізнес-правила (валідації, розрахунки, обмеження)
                реалізуються в прикладній логіці:
                у коді об’єктів, обробниках, workflow та автоматизаціях.
                Запитний шар не вважається джерелом істини для правил.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Запити активно використовуються у звітах та аналітиці (СКД),
                але проведення документів і контроль виконуються в коді.
                Один і той самий показник часто рахується:
                один раз у запиті, вдруге — в обробнику.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Розрахунки розподіляються між CDS View, ABAP-кодом та налаштуваннями.
                Ці рівні потужні, але не утворюють єдиної мови правил.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Views та FetchXML — для читання,
                бізнес-правила — у плагінах, flows та клієнтських скриптах.
                Запит не є носієм логіки.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                ORM-запити використовуються для вибірок,
                а логіка реалізується в Python-коді та computed fields.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                неможливо однозначно відповісти,
                де саме рахується показник і яка версія формули «головна».
              </p>

              <p>
                <strong>Як перевірити:</strong>
                попросити показати всі місця,
                де використовується один і той самий розрахунок,
                і як забезпечується їхня ідентичність.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-3-2">3.2 Запити у вигляді рядків</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Запити та умови часто задаються у вигляді рядків:
                текст SQL, вирази фільтрів, формули в налаштуваннях.
                Платформа не може аналізувати їхню структуру
                і перевіряти вплив змін.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Запити — рядкові.
                Помилки та залежності виявляються лише в рантаймі.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                У стандартних шарах контроль вищий,
                але кастом та інтеграції швидко приводять до текстових конструкцій.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Умови й вирази у flows та налаштуваннях
                формально no-code, але по суті рядкові.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Raw SQL вирішує задачі,
                але ламає аналіз залежностей і оновлення.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                зміна схеми даних призводить до помилок «постфактум»,
                з’являється правило «краще не чіпати».
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-3-3">3.3 Відсутність передбачуваної оптимізації як частини моделі правил</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Продуктивність запитів не виводиться з моделі правил.
                Вона досягається коштом ручної оптимізації,
                індексів та досвіду розробників.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Запит може бути логічно коректним,
                але фізично неефективним.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Сильна СУБД допомагає,
                але складні моделі дають неочікувані плани виконання.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Складну аналітику часто виносять у BI,
                а не оптимізують усередині ERP.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                ORM приховує реальні плани виконання,
                оптимізація стає «мистецтвом».
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                звіти «літають» на тесті й деградують на реальних даних.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-3-4">3.4 Відсутність розширених SQL-можливостей</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Підтримка віконних функцій, CTE та умовних агрегатів
                або обмежена, або потребує обхідних шляхів.
                У результаті розрахунки розпадаються на кілька кроків та код.
              </p>

              <p><strong>Експлуатаційний симптом:</strong>
                однакові формули дублюються,
                складно зрозуміти, де саме рахується показник.
              </p>

              <p>
                <strong>Як перевірити:</strong>
                попросити показати складний управлінський розрахунок
                без циклів і тимчасових таблиць.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-3-5">3.5 Відсутність запитів на зміну (UPDATE / DELETE / MERGE)</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Масові зміни даних
                не вважаються штатною частиною мови запитів.
                Використовуються цикли, обробки або зовнішні інструменти.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Масові зміни = перебір об’єктів і перепроведення.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Масові операції можливі,
                але потребують високої кваліфікації та обережності.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Масові зміни часто виносяться в ETL та Dataflows.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                ORM повільний для масових операцій,
                raw SQL ризикований з точки зору підтримки.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                перерахунки виконуються вночі,
                вважаються небезпечними й рідкісними.
              </p>

            </section>

            <!-- ===================================================== -->
            <section class="post-content" id="execution-flow">

              <h2 id="execution-flow-title">4. Потік виконання і гарантії консистентності даних</h2>
              <p>
                Цей розділ — про гарантії, а не про зручність.
                Про те, <strong>чи можна формально визначити момент завершення операції</strong>,
                джерело істини та порядок застосування бізнес-правил.
                Саме відсутність формальних гарантій приводить до помилок,
                які «неможливо відтворити», і підриває довіру до даних.
              </p>

              <hr>

              <h3 id="limit-4-1">4.1 Відмова від автоматичних блокувань</h3>

              <p><strong>Суть обмеження</strong></p>
              <p>
                Багато ERP жертвують строгими блокуваннями заради чутливості інтерфейсу.
                У результаті платформа не гарантує атомарність бізнес-операції:
                кілька користувачів або процесів можуть змінити пов’язані дані
                без єдиної точки синхронізації.
              </p>

              <p><strong>Гарантії, яких немає</strong></p>
              <p>
                Немає формального твердження:
                «у момент X дані були узгоджені та не могли змінюватися конкурентно».
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                рідкі, нерегулярні помилки,
                які неможливо стабільно відтворити;
                пояснення зводиться до «одночасних дій».
              </p>

              <p>
                <strong>Як перевірити:</strong>
                попросити показати,
                що відбувається при одночасній зміні
                одного й того ж об’єкта кількома користувачами
                і де саме фіксується конфлікт.
              </p>

              <hr>

              <h3 id="limit-4-2">4.2 Відмова від єдиного потоку виконання</h3>

              <p><strong>Суть обмеження</strong></p>
              <p>
                Бізнес-логіка розподіляється між клієнтом,
                сервером, фоновими процесами та інтеграціями.
                У системі відсутній єдиний детермінований потік виконання.
              </p>

              <p><strong>Гарантії, яких немає</strong></p>
              <p>
                Неможливо формально відповісти:
                «які перевірки та розрахунки були застосовані саме до цієї операції».
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                користувач бачить одну поведінку,
                а підсумковий стан даних відрізняється;
                виникають «незрозумілі» відмови й відкати.
              </p>

              <p>
                <strong>Як перевірити:</strong>
                попросити показати,
                які перевірки виконуються гарантовано на сервері,
                які — лише в UI,
                і що станеться при обході інтерфейсу.
              </p>

              <hr>

              <h3 id="limit-4-3">4.3 Відмова від синхронності та чіткого commit point</h3>

              <p><strong>Суть обмеження</strong></p>
              <p>
                Заради швидкості операції виконуються асинхронно:
                розрахунки, інтеграції, перерахунки показників.
                Користувач отримує підтвердження,
                але бізнес-операція ще не завершена логічно.
              </p>

              <p><strong>Гарантії, яких немає</strong></p>
              <p>
                Відсутній чіткий commit point —
                момент, після якого можна стверджувати,
                що операція завершена і її ефект остаточний.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                дублювання операцій,
                «відкладені помилки»,
                ручні перевірки та повторні дії користувачів.
              </p>

              <p>
                <strong>Як перевірити:</strong>
                запитати,
                в який момент операція вважається завершеною,
                які дії виконуються після підтвердження
                і чи можливі відкати заднім числом.
              </p>

            </section>

            <!-- ===================================================== -->
            <section class="post-content" id="forms-layer">

              <h2 id="forms-layer-title">5. Форми та подання даних</h2>
              <p>
                Цей розділ — про те, як користувач взаємодіє з моделлю даних
                і які архітектурні наслідки виникають,
                коли інтерфейс перестає бути прямим відображенням бізнес-логіки.
                Тут помилки виглядають як «людський фактор»,
                але їхня причина — в устрої системи.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-5-1">5.1 Форми як окремий шар логіки</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Форми в ERP рідко є просто відображенням даних.
                У них додається логіка:
                перевірки, обчислення, приховування полів,
                автозаповнення, реакції на події.
                З часом форма стає ще одним місцем,
                де «живуть» бізнес-правила.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Значна частина логіки реалізується в модулях форм:
                перевірки при зміні полів,
                перерахунки, керування доступністю.
                Ця логіка не завжди дублюється на сервері.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                UI-логіка розподіляється між екранними сценаріями,
                backend-перевірками та процесними правилами.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Клієнтські скрипти та бізнес-правила в інтерфейсі
                доповнюють серверні плагіни,
                створюючи кілька рівнів поведінки.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Форми відносно прості,
                але при кастомізації логіка починає дублювати backend.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                поведінка залежить від того,
                як саме користувач вводить дані,
                через яку форму або сценарій.
              </p>

              <p>
                <strong>Як перевірити:</strong>
                попросити показати,
                які перевірки виконуються лише у формі
                і що станеться при завантаженні даних в обхід UI.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-5-2">5.2 Відмова від WYSIWYG: розділення інтерфейсу на запис і читання</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Режими перегляду та редагування
                реалізуються по-різному:
                різні події, різні перевірки,
                різні обчислення.
                Користувач бачить одне,
                а система зберігає інше.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Різні режими форми та події
                приводять до розходжень
                між відображенням і збереженням.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Багатокрокові екрани та статуси
                ускладнюють розуміння,
                що саме зафіксовано.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Частина полів обчислюється або оновлюється асинхронно,
                що створює ефект «візуальної фіксації».
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Базово WYSIWYG дотримано,
                але при ускладненні форм з’являються розходження.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                користувач упевнений, що дані збережено,
                але система пізніше їх змінює або відкатує.
              </p>

              <p>
                <strong>Як перевірити:</strong>
                попросити показати,
                чи збігається значення поля на екрані
                з тим, що реально записано в базі
                в момент збереження.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-5-3">5.3 Неможливість звертатися в списках до реквізитів форм і поточних значень інших списків</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Списки та форми живуть у різних контекстах.
                Логіка списку обмежена доступними полями даних,
                а поточні значення форми або інших списків
                недоступні напряму.
              </p>

              <p><strong>Наслідок</strong></p>
              <p>
                Контекстні правила (залежні від поточного вибору,
                стану форми, пов’язаних списків)
                реалізуються обхідними шляхами або дублюються.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                інтерфейс не може коректно відобразити
                реальні обмеження та правила,
                з’являються «незрозумілі» заборони.
              </p>

              <p>
                <strong>Як перевірити:</strong>
                попросити реалізувати правило,
                залежне від стану кількох списків,
                без додаткового коду й обходів.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-5-4">5.4 Надлишкові рівні абстракції в UI</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Для універсальності та розширюваності
                інтерфейс будують через кілька рівнів:
                метадані → форми → конфігурації → сценарії.
                Кожен рівень додає гнучкість,
                але знижує прозорість.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                проста зміна поведінки форми
                потребує розуміння кількох рівнів абстракції
                і зачіпає більше місць, ніж очікується.
              </p>

              <p>
                <strong>Як перевірити:</strong>
                попросити показати,
                через які шари проходить зміна
                одного UI-правила
                і де саме воно зафіксоване.
              </p>

            </section>

            <!-- ===================================================== -->
            <section class="post-content" id="language-architecture">

              <h2 id="language-architecture-title">6. Архітектура мови та розширюваність</h2>
              <p>
                Цей розділ — про те, <strong>наскільки ERP взагалі є інженерною платформою</strong>,
                а не набором інструментів для конфігурації.
                Тут визначається, чи можна розвивати систему як кодову базу
                з передбачуваними змінами,
                або вона неминуче перетворюється на артефакт впровадження,
                залежний від конкретних людей та домовленостей.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-6-1">6.1 Відсутність спадкування й поліморфізму</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                ERP майже завжди працює з сімействами сутностей:
                договори, замовлення, послуги, проєкти.
                Однак у багатьох платформах
                немає повноцінної моделі спадкування бізнес-сутностей.
                У результаті схожа логіка копіюється,
                а відмінності реалізуються через умови.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Спадкування обмежене.
                Типовий підхід — копіювання об’єктів
                із подальшими доопрацюваннями.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Можливості ширші,
                але складність моделі приводить до того,
                що логіка базових і похідних сутностей
                розходиться по розширеннях.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Розширення сутностей можливе,
                але поліморфізм частіше імітується
                через плагіни та умови.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Спадкування — сильна сторона,
                але при активних override'ах
                важливо контролювати точки зміни поведінки.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                правила дублюються,
                зміни в «базовій логіці»
                потребують ручної синхронізації.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-6-2">6.2 Відсутність явної типізації в коді</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Явна типізація часто відсутня
                або ослаблена заради гнучкості.
                Помилки виявляються в рантаймі,
                а аналіз логіки можливий
                лише дослідним шляхом.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Слабка типізація ускладнює аналіз
                великих конфігурацій
                та безпечний рефакторинг.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Типізація сильніша,
                але ціна — висока складність
                і вимоги до кваліфікації команди.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Типи є,
                але при змішуванні low-code та плагінів
                контракт поведінки розмивається.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Динамічний Python
                потребує строгих домовленостей,
                інакше помилки проявляються пізно.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                зміни перевіряються «на око»,
                зростає кількість регресійних помилок.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-6-3">6.3 Відсутність модульності</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Формальний поділ на модулі
                не гарантує архітектурної ізоляції.
                Залежності стають неявними,
                а зміна одного блоку
                зачіпає суміжні.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Загальні модулі розростаються,
                межі відповідальності розмиваються.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Модульність є на рівні процесів,
                але налаштування та розширення
                розмивають межі.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Композиційність працює
                до певного масштабу,
                потім локальність змін втрачається.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Модульність від початку сильна,
                але слабкий контроль залежностей
                перетворює оновлення на проєкт.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                «маленькі» зміни
                перестають бути маленькими,
                зростає обсяг регресу.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-6-4">6.4 Ставка на візуальне програмування</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Low-code та візуальні схеми
                прискорюють старт,
                але погано масштабуються
                як носій бізнес-логіки.
                Залежності складно аналізувати,
                правила важко тестувати.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Візуальні механізми
                змішуються з кодом,
                логіка «розпилюється».
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Workflow та налаштування потужні,
                але трасування «чому спрацювало»
                стає нетривіальним.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Flows зручні,
                але зі зростанням перетворюються
                на важкокерований набір сценаріїв.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Візуальні інструменти менш агресивні,
                але перенесення логіки з коду в налаштування
                дає ті самі ефекти.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                правила існують як «схеми»,
                а не як єдина модель,
                супровід залежить від конкретних людей.
              </p>

            </section>

            <!-- ===================================================== -->
            <section class="post-content" id="physical-model">

              <h2 id="physical-model-title">7. Фізична модель і відкритість системи</h2>
              <p>
                Цей розділ — про те, <strong>наскільки ERP прозора як інженерна система</strong>.
                Навіть за акуратної логіки, хороших форм і дисципліни розробки
                закрита або негнучка фізична модель даних
                різко збільшує вартість змін, діагностики й інтеграцій.
              </p>
              <p>
                Тут з’являються обмеження, які неможливо «обійти акуратним кодом» —
                вони визначаються самим устроєм платформи.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-7-1">7.1 Закрита фізична модель даних</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                У багатьох ERP фізична модель даних або прихована,
                або доступна лише через абстракції платформи.
                Розробник працює з логічною моделлю,
                не маючи повного контролю над тим,
                як дані реально зберігаються та пов’язані.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Фізична структура БД формується платформою.
                Прямий аналіз і оптимізація можливі,
                але не вважаються штатним способом роботи.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Модель даних формально відкрита,
                але надзвичайно складна.
                Без глибокої експертизи втручання ризиковане.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                У SaaS-моделі фізична БД прихована.
                Робота ведеться через Dataverse, API та вітрини.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Фізична модель доступна,
                але модулі та кастомізація
                швидко ускладнюють реальну картину.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                діагностика проблем і аналіз наслідків змін
                потребують спеціальних знань або доступу,
                який є не в команди, а у вендора або інтегратора.
              </p>

              <p>
                <strong>Як перевірити:</strong>
                запитати,
                чи можна без обхідних шляхів
                проаналізувати реальні таблиці,
                індекси та зв’язки для конкретного розрахунку.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-7-2">7.2 Статична фізична модель даних</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Фізична модель оптимізована під типові сценарії.
                Зміна структури даних
                або неможлива,
                або потребує складних міграцій і погоджень.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Зміни структури можливі,
                але на великих обсягах даних
                перетворюються на окремі проєкти.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Зміни допустимі,
                але зачіпають багато залежних об’єктів
                і потребують строгої процедури.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                Розширення схеми можливе,
                але в межах обмежень SaaS-платформи.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Модель можна змінювати,
                але це впливає на оновлюваність і сумісність модулів.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                зміна моделі даних відкладається,
                накопичуються «тимчасові» рішення та додаткові таблиці.
              </p>

              <p>
                <strong>Як перевірити:</strong>
                попросити показати,
                як додається новий вимір або сутність
                з урахуванням історичних даних.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-7-3">7.3 Закриті вихідні коди та ліцензії</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Вихідний код та внутрішні механізми
                частково або повністю закриті.
                Можливості аналізу та змін
                обмежені умовами ліцензії.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Платформа закрита,
                поведінку багатьох механізмів неможливо вивчити напряму.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Код доступний обмежено,
                зміни потребують дотримання строгих правил.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                SaaS-модель посилює залежність від вендора
                та обмежує низькорівневий контроль.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Open-source ядро знижує бар’єр,
                але комерційні модулі та екосистема
                можуть створювати новий lock-in.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                команда не може самостійно розібратися
                в причинах поведінки системи
                і змушена покладатися на підтримку або партнерів.
              </p>

              <p>
                <strong>Як перевірити:</strong>
                запитати,
                які частини системи можна аналізувати,
                дебажити та змінювати без участі вендора.
              </p>

            </section>

            <!-- ===================================================== -->
            <section class="post-content" id="operational-constraints">

              <h2 id="operational-constraints-title">8. Експлуатаційні та культурні обмеження</h2>
              <p>
                Цей розділ — про обмеження, які формально не належать до архітектури,
                але на практиці <strong>визначають, якою архітектурою система може бути</strong>.
                Ліцензування, правила використання та позиція вендора
                напряму впливають на тестування, автоматизацію,
                швидкість змін і залежність від зовнішніх учасників.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-8-1">8.1 Неповага до розробників у ліцензуванні та брендованості</h3>

              <p><strong>Як це зазвичай реалізовано в стандартних ERP</strong></p>
              <p>
                Ліцензування часто будується навколо користувачів,
                середовищ і окремих компонентів.
                Це обмежує кількість тестових стендів,
                ускладнює CI/CD і робить експерименти дорогими.
                Брендованість і жорсткі правила використання
                підкреслюють залежність від вендора.
              </p>

              <p><strong>1С</strong></p>
              <p>
                Ліцензії на користувачів і сервери
                обмежують кількість повноцінних контурів.
                Часто існує один «живий» стенд,
                де й тестують зміни.
              </p>

              <p><strong>SAP</strong></p>
              <p>
                Вартість ліцензій і середовищ
                робить кожен додатковий стенд предметом погодження.
                Автоматизація тестування обмежена.
              </p>

              <p><strong>Microsoft Dynamics</strong></p>
              <p>
                SaaS-ліцензування обмежує доступ
                до низькорівневих механізмів
                і ускладнює ізоляцію експериментів.
              </p>

              <p><strong>Odoo</strong></p>
              <p>
                Open-source знижує бар’єр входу,
                але комерційні модулі та сервіси
                можуть накладати схожі обмеження.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                менше тестових контурів,
                правки перевіряються «на проді»,
                зміни викочуються рідше й обережніше,
                ніж потребує бізнес.
              </p>

              <p>
                <strong>Як перевірити:</strong>
                запитати,
                скільки повноцінних середовищ
                можна тримати без додаткових ліцензій
                і які з них придатні для автоматичних тестів.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="limit-8-2">8.2 Фатальний недолік як сума архітектурних рішень</h3>

              <p>
                Жодне з описаних обмежень
                не є фатальним саме по собі.
                Проблема виникає,
                коли вони накладаються одне на одне.
              </p>

              <ul>
                <li>правила «розмазані» по об’єктах, формах і запитах;</li>
                <li>запитний шар не є джерелом істини;</li>
                <li>немає чітких гарантій потоку виконання;</li>
                <li>модель даних закрита або негнучка;</li>
                <li>експерименти та тестування дорогі.</li>
              </ul>

              <p>
                У такій системі будь-яка зміна —
                навіть логічно проста —
                перетворюється на проєкт:
                з аналізом наслідків,
                ручним регресом
                і залежністю від конкретних людей.
              </p>

              <p>
                <strong>Експлуатаційний симптом:</strong>
                команда уникає змін,
                бізнес перестає ставити запитання «а чи можна інакше»,
                ERP фіксує поточний спосіб роботи
                замість того, щоб підтримувати розвиток.
              </p>

            </section>

            <!-- ===================================================== -->
            <section class="post-content" id="demo-pilot-check">

              <h2 id="demo-pilot-check-title">9. Як перевіряти архітектурні обмеження на демо та пілоті</h2>
              <p>
                Архітектурні обмеження майже ніколи не видно
                у презентаціях та типових сценаріях.
                На демо показують «що система вміє»,
                але не «скільки коштує зміна правил».
              </p>
              <p>
                Єдиний надійний спосіб —
                перевіряти ERP не за функціями,
                а за <strong>реакцією на зміни</strong>.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="demo-what-to-ask">9.1 Три зміни, які варто попросити показати</h3>

              <p>
                Для перевірки достатньо трьох сценаріїв.
                Важливо не те, що «вийшло»,
                а <strong>як саме це робили</strong>.
              </p>

              <ol>
                <li>
                  <strong>Зміна правила з винятками</strong><br>
                  Наприклад: знижка або ліміт,
                  залежні від кількох умов
                  (тип клієнта, оборот, ризик, історія).
                </li>
                <li>
                  <strong>Зміна процесу</strong><br>
                  Погодження не «за посадою»,
                  а за даними:
                  сума, маржа, ризик, відхилення від норми.
                </li>
                <li>
                  <strong>Додавання нового типу сутності</strong><br>
                  Новий договір, послуга або модель розрахунку,
                  яка має:
                  брати участь у транзакціях,
                  потрапляти у звіти
                  і підпорядковуватися тим самим правилам контролю.
                </li>
              </ol>

              <p>
                Ці сценарії зачіпають:
                модель даних,
                розрахунки,
                форми,
                запити,
                контроль та інтеграції —
                саме там і проявляються обмеження.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="demo-what-to-watch">9.2 На що дивитися під час демонстрації</h3>

              <ul>
                <li>
                  <strong>Скільки шарів довелося змінювати</strong><br>
                  Один модуль або форма —
                  це зміна правила.
                  Кілька шарів —
                  зміна системи.
                </li>
                <li>
                  <strong>Де саме описано правило</strong><br>
                  Чи можна показати одне місце,
                  або логіка розподілена
                  між кодом, формами та запитами.
                </li>
                <li>
                  <strong>Як пояснюється вплив на звіти</strong><br>
                  Чи є чітка відповідь,
                  які показники зміняться
                  і чому.
                </li>
                <li>
                  <strong>Чи є перевірка регресу</strong><br>
                  Тест, сценарій або хоча б формальний чек-лист,
                  а не «потім подивимось».
                </li>
              </ul>

              <hr>

              <!-- ===================================================== -->
              <h3 id="demo-red-flags">9.3 Типові «червоні прапорці»</h3>

              <ul>
                <li>«Це краще робити після впровадження»</li>
                <li>«У реальному проєкті ми б зробили інакше»</li>
                <li>«Тут багато нюансів, на демо не показати»</li>
                <li>«Це робиться, але потрібен окремий проєкт»</li>
                <li>«Треба подивитися, як це вплине на звіти»</li>
              </ul>

              <p>
                Ці фрази не означають,
                що система погана.
                Вони означають,
                що вартість змін
                поки невідома й неконтрольована.
              </p>

              <hr>

              <!-- ===================================================== -->
              <h3 id="demo-result">9.4 Що вважати добрим результатом пілота</h3>

              <p>
                Добрий результат —
                не «ми все зробили»,
                а таке:
              </p>

              <ul>
                <li>правило описано в одному місці або в одному типі механізму;</li>
                <li>видно, які дані та розрахунки воно зачіпає;</li>
                <li>зрозуміло, як перевірити регрес;</li>
                <li>зміна не потребує «особливого знання» конкретної людини.</li>
              </ul>

              <p>
                Якщо після пілота можна відповісти на запитання
                <strong>«скільки коштує наступна зміна»</strong>,
                значить архітектура піддається керуванню.
              </p>

            </section>

            <!-- ===================================================== -->
            <section class="post-content" id="conclusion">

              <h2 id="conclusion-title">10. Висновок</h2>

              <p>
                Цей розбір не про «хороші» й «погані» ERP.
                1С, SAP, Microsoft Dynamics та Odoo успішно працюють у тисячах компаній.
                Проблеми починаються не на етапі впровадження, а в момент, коли бізнес починає <strong>змінювати правила</strong>.
              </p>

              <p>
                Архітектурні обмеження рідко виглядають критичними поодинці.
                Вони накопичуються:
                через додаткові перевірки,
                приватні доробки,
                винятки та тимчасові обходи.
                З часом саме вони визначають реальну вартість змін.
              </p>

              <p>
                Ключовий висновок:
                <strong>дорогими стають не складні правила, а погано формалізовані</strong>.
                Коли логіка «розмазана» між об’єктами, формами, запитами,
                візуальними сценаріями та інтеграціями,
                система перестає бути керованою як єдине ціле.
              </p>

              <p>
                У такій архітектурі виникає практичний lock-in —
                не стільки від вендора,
                скільки від конкретних людей,
                які «пам’ятають, як усе працює».
              </p>

              <p>
                У контексті ERP роль AI часто розуміють надто поверхнево —
                як інструмент підказок, генерації коду або прискорення окремих задач.
                Але його реальний архітектурний ефект проявляється в іншому.
              </p>

              <p>
                AI стає стратегічним активом тоді, коли платформа
                дозволяє <strong>навчати модель на власній бізнес-логіці</strong>,
                а не використовувати її лише як зовнішнього помічника.
              </p>

              <div class="callout">
                <strong>Ключова ідея</strong>
                <p>
                  Якщо мова й модель даних ERP достатньо структуровані,
                  компактні та однозначні, компанія може навчити AI на своєму коді
                  і правилах — і далі розвивати систему силами власної команди,
                  без постійної залежності від вендора чи вузьких спеціалістів.
                </p>
              </div>

              <p>
                Для цього платформа має мати кілька критичних властивостей:
              </p>

              <ul>
                <li><strong>Висока щільність змісту</strong> — бізнес-правила виражаються коротко, без надлишкового коду.</li>
                <li><strong>Декларативність</strong> — правила описують «що має бути», а не «як саме виконати».</li>
                <li><strong>Єдина модель</strong> — дані, правила й обчислення описуються в одному формалізмі.</li>
                <li><strong>Відсутність «магії»</strong> — мінімальна кількість неявних обробників, подій і винятків.</li>
              </ul>

              <p>
                У такій системі AI навчається швидше й точніше:
                йому не потрібно аналізувати тисячі рядків процедурного коду,
                розрізнені форми, рядкові запити та візуальні сценарії.
                Модель бачить саме <strong>структуру правил</strong>, а не історію впровадження.
              </p>

              <p>
                Практичний наслідок цього підходу —
                різке зниження «вартості володіння знаннями»:
              </p>

              <ul>
                <li>менше токенів і обчислень для навчання та супроводу моделей,</li>
                <li>вища точність аналізу змін і наслідків,</li>
                <li>менша залежність від конкретних людей і підрядників,</li>
                <li>можливість підтримувати й розвивати ERP внутрішньою командою.</li>
              </ul>

              <p>
                У протилежному випадку — коли бізнес-логіка «розмазана»
                по об’єктах, формах, рядкових запитах, візуальних схемах
                та історичних винятках — AI не стає стратегічним активом.
                Він лише прискорює роботу з хаотичною системою, але не знижує її вартість.
              </p>

              <div class="callout">
                <strong>Висновок</strong>
                <p>
                  Архітектура, зрозуміла не лише людям, а й машинам,
                  — це не «мода» і не маркетинг.
                  Це прямий шлях до зниження vendor lock-in
                  і до того, щоб ERP розвивалася разом із бізнесом,
                  а не вимагала щоразу зовнішнього втручання.
                </p>
              </div>

            </section>

            <hr>

            <h2 id="sources">Джерела та посилання</h2>
            <ul>
              <li>
                <a href="https://habr.com/ru/companies/lsfusion/articles/544982/" target="_blank" rel="noopener noreferrer">
                  “ERP, яка не ламається від змін” (Habr) ↗
                </a>
              </li>
              <li>
                <a href="https://habr.com/ru/companies/lsfusion/articles/468415/" target="_blank" rel="noopener noreferrer">
                  “Обмеження 1С:Підприємства” (Habr) ↗
                </a>
              </li>
            </ul>

            <h2 id="related-posts">Схожі статті</h2>
            <div class="callout">
              <strong>Продовжити читання:</strong>
              <p>
                Якщо важливі практичні наслідки архітектури ERP та зниження залежності від підрядників —
                ось ще матеріали на DevLab Blog:
              </p>
              <ul>
                <li>
                  <a href="https://uk.devlab.blog/posts/post13-open-source-erp-low-code.html" target="_blank" rel="noopener noreferrer">
                    Open-source ERP і low-code: які бізнес-системи реально використовують компанії ↗
                  </a>
                </li>
                <li>
                  <a href="https://uk.devlab.blog/main-erp-stack-2032-ai-readable-architectures.html" target="_blank" rel="noopener noreferrer">
                    Чому ERP майбутнього будуть модульними, декларативними та «читабельними» для AI ↗
                  </a>
                </li>
              </ul>
            </div>
          </section>

          <footer class="post-footer-extended">
            <div class="post-footer-meta">
              <div class="post-meta-tags">
                <span class="post-tag">ERP</span>
                <span class="post-tag">Архітектура</span>
                <span class="post-tag">Супровід</span>
                <span class="post-tag">1С</span>
                <span class="post-tag">SAP</span>
                <span class="post-tag">Dynamics</span>
                <span class="post-tag">Odoo</span>
                <span class="post-tag">Інтеграції</span>
                <span class="post-tag">Vendor lock-in</span>
                <span class="post-tag">Low-code</span>
              </div>

              <div class="post-meta-secondary">
                <span>Опубліковано: 22 січ 2026</span>
                <span>·</span>
                <span>Приблизно 10–12 хв читання</span>
                <span>·</span>
                <span class="post-views">Перегляди: <span class="count">—</span></span>
              </div>
            </div>
          </footer>

          <!-- Inline newsletter -->
          <section class="sidebar-block">
            <p class="sidebar-text">
              Без спаму — лише рідкі нотатки про ERP, автоматизацію та нові статті.
            </p>
            <form class="newsletter-form"
                  action="https://formsubmit.co/info@devlab.blog"
                  method="POST">
              <input type="hidden" name="_next" value="https://uk.devlab.blog/thank-you.html">
              <input type="hidden" name="_captcha" value="false">
              <input type="text" name="_honey" style="display:none">

              <input type="email" name="email" class="field" placeholder="Ваш email" required>
              <button class="btn btn-primary" type="submit">Підписатися</button>

              <p class="newsletter-note">
                Ви отримаєте лист підтвердження.<br>
                Працює через FormSubmit.
              </p>
            </form>

            <h2 id="feedback">Швидкий фідбек</h2>
            <div class="callout">
              <strong>Було корисно?</strong>
              <p>Короткий сигнал допомагає нам обирати наступні теми.</p>

              <div class="hero-actions">
                <button class="btn btn-primary" type="button" data-vote="like">
                  👍 Так <span class="count" data-count="like">—</span>
                </button>

                <button class="btn btn-outline" type="button" data-vote="dislike">
                  👎 Не дуже <span class="count" data-count="dislike">—</span>
                </button>
              </div>

              <p class="sidebar-text">Без коментарів і акаунтів.</p>
            </div>
          </section>

          <div class="post-nav-links">
            <a class="back" href="/#posts" style="margin-left: 0;">← Назад до всіх статей</a>
            <a class="back" href="/#categories" style="margin-right: 0;">Категорії →</a>
          </div>
        </article>

        <!-- SIDEBAR -->
        <aside class="sidebar">
          <section class="sidebar-block">
            <h3 class="sidebar-title" id="topic-question-title">Запропонувати тему</h3>
            <p class="sidebar-text">
              Маєте запитання або ідею для наступної статті?
              <a class="post-read" href="mailto:info@devlab.blog?subject=Ідея%20або%20питання%20для%20DevLab%20Blog">
                Написати нам →
              </a>
            </p>
          </section>

          <section class="sidebar-block">
            <h3 class="sidebar-title">Про блог</h3>
            <p class="sidebar-text">
              DevLab Blog — нотатки про open-source ERP, модульні підходи, інтеграції та практику автоматизації.
              Пишемо про те, що ламається в реальних впровадженнях, і як ухвалювати технологічні рішення без “релігії”.
            </p>
          </section>

          <section class="sidebar-block">
            <h3 class="sidebar-title">Ще</h3>
            <p class="sidebar-text">
              Поверніться на головну сторінку або оберіть категорію:
            </p>
            <ul>
              <li><a href="/">Усі статті</a></li>
              <li><a href="/#categories">Категорії</a></li>
              <li><a href="https://devlab.blog" target="_blank" rel="noopener noreferrer">Головний сайт DevLab</a></li>
            </ul>
          </section>
        </aside>
      </div>
    </div>
  </main>

  <!-- FOOTER -->
  <footer class="site-footer">
    <div class="wrapper footer-grid">
      <div>
        <div class="footer-links">
          <a href="/">Статті</a>
          <a href="/#categories">Категорії</a>
          <a href="/#about">Про блог</a>
          <a href="https://devlab.blog" target="_blank" rel="noopener noreferrer">Головний сайт</a>
        </div>
        <p class="footer-meta">
          DevLab Blog — нотатки про open-source ERP, модульні архітектури та автоматизацію.
        </p>
      </div>
      <div class="footer-meta">
        <p>&copy; <span id="year"></span> DevLab Blog</p>
      </div>
    </div>
  </footer>
</div>
</body>
</html>
